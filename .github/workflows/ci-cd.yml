name: CI/CD Pipeline

on:
  push:
    branches: [dev, main]
  pull_request:
    branches: [main]

env:
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
      with:
        token: ${{ secrets.PAT }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
      with:
        token: ${{ secrets.PAT }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks get-token --cluster-name ${{ env.EKS_CLUSTER_NAME }} | aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

    - name: Create Namespaces
      run: |
        kubectl create namespace dev --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace prod --dry-run=client -o yaml | kubectl apply -f -

    - name: Create or Update ArgoCD Application
      env:
        ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        metadata:
          name: sample-app
          namespace: argocd
        spec:
          project: default
          source:
            repoURL: ${{ github.server_url }}/${{ github.repository }}
            path: k8s/$ENVIRONMENT
            targetRevision: ${{ github.sha }}
          destination:
            server: https://kubernetes.default.svc
            namespace: $ENVIRONMENT
          syncPolicy:
            automated:
              prune: true
              selfHeal: true
        EOF

    - name: Verify ArgoCD Application
      run: |
        echo "Verifying ArgoCD Application..."
        kubectl get application sample-app -n argocd -o yaml
        echo "ArgoCD Application Resources:"
        kubectl get application sample-app -n argocd -o jsonpath='{.status.resources}' | jq

    - name: Update Kubernetes manifests
      env:
        ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        sed -i 's|${ECR_REGISTRY}|'$ECR_REGISTRY'|g' k8s/$ENVIRONMENT/deployment.yaml
        sed -i 's|${ECR_REPOSITORY}|'$ECR_REPOSITORY'|g' k8s/$ENVIRONMENT/deployment.yaml
        sed -i 's|${IMAGE_TAG}|'$IMAGE_TAG'|g' k8s/$ENVIRONMENT/deployment.yaml
        sed -i 's|${ENVIRONMENT}|'$ENVIRONMENT'|g' k8s/$ENVIRONMENT/deployment.yaml

    - name: Commit and push updated manifests
      run: |
        git config --global user.name 'GitHub Actions'
        git config --global user.email 'github-actions@github.com'
        git add k8s/
        git commit -m "Update image tag to ${{ github.sha }}" || echo "No changes to commit"
        git push

    - name: Wait for Sync to Complete
      run: |
        echo "Waiting for sync to complete..."
        for i in {1..30}; do
          sync_status=$(kubectl get application sample-app -n argocd -o jsonpath='{.status.sync.status}')
          health_status=$(kubectl get application sample-app -n argocd -o jsonpath='{.status.health.status}')
          echo "Attempt $i: Sync Status: $sync_status, Health Status: $health_status"
          
          if [ "$sync_status" = "Synced" ]; then
            echo "Application synced successfully"
            break
          fi
          
          if [ $i -eq 30 ]; then
            echo "Timeout waiting for application to sync"
            kubectl get application sample-app -n argocd -o yaml
            exit 1
          fi
          
          sleep 10
        done
        
        echo "Checking application health..."
        for i in {1..30}; do
          health_status=$(kubectl get application sample-app -n argocd -o jsonpath='{.status.health.status}')
          echo "Attempt $i: Health Status: $health_status"
          
          if [ "$health_status" = "Healthy" ]; then
            echo "Application is healthy"
            exit 0
          fi
          
          if [ $i -eq 30 ]; then
            echo "Timeout waiting for application to become healthy"
            kubectl get application sample-app -n argocd -o yaml
            exit 1
          fi
          
          sleep 10
        done
        
        echo "Application failed to become healthy"
        kubectl get application sample-app -n argocd -o yaml
        exit 1

    - name: Debug Information
      if: failure()
      run: |
        echo "Debug information:"
        kubectl get pods -n argocd
        kubectl get application sample-app -n argocd -o yaml
        kubectl logs -n argocd -l app.kubernetes.io/name=argocd-application-controller --tail=100
        kubectl describe application sample-app -n argocd
        
        echo "Checking resources in target namespace:"
        ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        kubectl get all -n $ENVIRONMENT
        
        echo "Checking events in target namespace:"
        kubectl get events -n $ENVIRONMENT
