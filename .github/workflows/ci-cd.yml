name: CI/CD Pipeline

on:
  push:
    branches: [dev, main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

env:
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          ENV_TAG="prod"
        else
          ENV_TAG="dev"
        fi
        IMAGE_TAG="${{ github.sha }}-${ENV_TAG}"
        
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks get-token --cluster-name ${{ env.EKS_CLUSTER_NAME }} | aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

    - name: Create or Update ArgoCD Application
      env:
        ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        metadata:
          name: sample-app-$ENVIRONMENT
          namespace: argocd
          annotations:
            argocd-image-updater.argoproj.io/image-list: myapp=$ECR_REGISTRY/$ECR_REPOSITORY
            argocd-image-updater.argoproj.io/myapp.update-strategy: latest
        spec:
          project: default
          source:
            repoURL: ${{ github.server_url }}/${{ github.repository }}
            path: k8s/$ENVIRONMENT
            targetRevision: ${{ github.sha }}
          destination:
            server: https://kubernetes.default.svc
            namespace: $ENVIRONMENT
          syncPolicy:
            automated:
              prune: true
              selfHeal: true
        EOF

    - name: Wait for Sync to Complete
      env:
        ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
      run: |
        echo "Waiting for sync to complete..."
        for i in {1..30}; do
          sync_status=$(kubectl get application sample-app-$ENVIRONMENT -n argocd -o jsonpath='{.status.sync.status}')
          health_status=$(kubectl get application sample-app-$ENVIRONMENT -n argocd -o jsonpath='{.status.health.status}')
          echo "Attempt $i: Sync Status: $sync_status, Health Status: $health_status"
          
          if [ "$sync_status" = "Synced" ] && [ "$health_status" = "Healthy" ]; then
            echo "Application synced and healthy"
            exit 0
          fi
          
          if [ $i -eq 30 ]; then
            echo "Timeout waiting for application to sync and become healthy"
            kubectl get application sample-app-$ENVIRONMENT -n argocd -o yaml
            echo "ArgoCD Application Controller Logs:"
            kubectl logs -n argocd -l app.kubernetes.io/name=argocd-application-controller --tail=100
            exit 1
          fi
          
          sleep 10
        done
